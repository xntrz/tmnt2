#pragma once

#include "PefInfo.hpp"


class CParticle
{
public:
    static const int32 VERTEXNUM = 26;
    static const int32 TRANSITIONNUM = 50;
    static const uint32 RANDSEED = 1000;
    
    struct TRANSITION : public CListNode<TRANSITION>
    {
        RwV3d m_vPositionBasis;
        RwV3d m_vPositionNow;
        RwV3d m_vPositionRand;
        RwV3d m_vPositionCircle;
        RwV3d m_vPosition;
        RwRGBA m_Color;
        RwRGBA m_ColorNow;
        RwMatrix m_matrix;
        RwV2d m_vSize;
        RwV2d m_vSizeNow;
        RwV3d m_vScale;
        RwV3d m_vScaleNow;
        RwV3d m_vDirection;
        RwV3d m_vVecFirst;
        float m_fSpeedFirst;
        RwV3d m_vAcceleration;
        float m_fAccelSpeed;
        float m_fCounter;
        float m_fCounterNow;
        float m_fLiveCount;
        int32 m_nOccurNum;
        int32 m_nDisplayNum;
        float m_fOccurTiming;
        float m_fRotSpeedBillboard;
        float m_fRotationBillboard;
        float m_fInitRotationBillboard;
        RwV3d m_vRotSpeed;
        RwV3d m_vRotation;
        float m_fSortZ;
    };

public:
    CParticle(void);
    ~CParticle(void);
    void Copy(const CParticle* pParticle);
    void ConvertEndian(PEFINFO::PARTICLEINFO* pParticleInfo);
    void ReadParticleData(PEFINFO::PARTICLEINFO* pParticleInfo);
    void Initialize(void);
    void StartParticle(void);
    void Run(float dt);
    void Draw(RwCamera* pCamera);
    void SetGravity(float fGravity);
    void SetUpdate(bool bUpdate);
    void SetLoop(bool bLoop);
    void SetBasisPositionForAll(const RwV3d* pvPosition);
    void SetBasisPosition(const RwV3d* pvPosition);
    void SetClippingInfo(PEFINFO::CLIPPINGTYPE clippingtype, float fParameter);
    void SetScale(float fScale);
    void SetVector(const RwV3d* pvAxisX, const RwV3d* pvAxisY, const RwV3d* pvAxisZ);
    bool IsStringParticle(void) const;
    bool IsEndParticle(void) const;
    bool IsDrawingParticle(void);
    void AddElapsedTime(float dt);
    void RenderStatePush(void);
    void RenderStatePop(void);
    void SetMatrixDirection(RwMatrix* pMatrix, const RwV3d* pvLookVec);
    void DeleteElement(void);
    void SetColorToVertex(const RwRGBA& color);
    bool GetMyTexture(void);
    void SetMyTexture(RwTexture* pTexture);
    void SetVertexInfo(RwIm3DVertex* aVertexList, RwCamera* pCamera, TRANSITION* pTransition, uint32 uStartPos);
    void DrawVertex(RwCamera* pCamera);
    void CreateCylinder(float fTopRadius, float fBottomRadius, int32 nPointNum, float fHeight);
    void RecreateCylinder(float fTopRadius, float fBottomRadius, int32 nPointNum, float fHeight);
    void DrawModel(RwMatrix* pMatrix);
    void UpdateTransition(TRANSITION* pTransition);
    void CreateParticle(TRANSITION* pInitTransition);
    void TransitionNatureFall(TRANSITION* pTransition, RwV3d* pvVec);
    void TransitionNatureRise(TRANSITION* pTransition, RwV3d* pvVec);
    void TransitionColor(TRANSITION* pTransition);
    void TransitionSize(TRANSITION* pTransition);
    void TransitionScale(TRANSITION* pTransition);
    void TransitionAcceleration(TRANSITION* pTransition);
    void TransitionRotation(TRANSITION* pTransition, const RwV3d* pCameraPos);
    float GetSortZ(RwCamera* pCamera, RwV3d* pvPosition);
    void SortZ(RwCamera* pCamera);
    void AddRandomStartPos(RwV3d* pvStartPos, RwV3d* pvRandElement, uint32 uRandomFlag);
    void AddRandomStartSize(RwV2d* pvStartSize, RwV2d* pvRandElement, uint32 uRandomFlag);
    float AddRandomStartLive(float fFirstLive, float fRandElement, uint32 uRandomFlag);
    void AddRandomFirstVec(RwV3d* pvFirstVec, RwV3d* pvRandomElement, uint32 uRandomFlag);
    float AddRandomSpeed(float fFirstSpeed, float fRandElement, uint32 uRandomFlag);
    void AddRandomAccelVec(RwV3d* pvAccelVec, RwV3d* pvRandomElement, uint32 uRandomFlag);
    float AddRandomAccel(float fAccel, float fRandElement, uint32 uRandomFlag);
    void RandomScale(RwV2d* pvStartSize, float fScaleMin, float fScaleMax, uint32 uRandomFlag);
    void RandomScale3D(RwV3d* pvStartSize, RwV3d* pvRandomElement, uint32 uRandomFlag);
    float RandomAngle(float fRandElement, uint32 uRandomFlag);
    void CircleMove(RwV3d* pvDest, float fRadius, float fSpeed, float fTime, uint32 uFlag);
    void CopyTransition(TRANSITION* pDst, TRANSITION* pOrg);
    float Randomize(void) const;
    
private:
    char m_szName[32];
    CList<TRANSITION> m_listTransitionPool;
    CList<TRANSITION> m_listTransitionAlloc;
    TRANSITION* m_paTransition;
    int32 m_nTransitionNum;
    int32 m_nTransitionMax;
    int32 m_nNowUseNum;
    float m_fCounter;
    bool m_bRun;
    bool m_bDraw;
    bool m_bLoop;
    bool m_bSimple;
    bool m_bFinish;
    char m_szTextureName[32];
    RwTexture* m_pMyTexture;
    float m_u0;
    float m_v0;
    float m_u1;
    float m_v1;
    int32 m_nRepetitionNum;
    float m_fColorDecayR;
    float m_fColorDecayG;
    float m_fColorDecayB;
    float m_fColorDecayA;
    float m_fColorDecayBuffer[4];
    float m_fSizeDecayWidth;
    float m_fSizeDecayHeight;
    float m_fSizeDecayBuffer[2];
    RwV3d m_vScaleDecay;
    RwV3d m_vScaleDecayBuffer;
    int32 m_nVertexNum;
    float m_fTopRadius;
    float m_fBottomRadius;
    float m_fHeight;
    int32 m_nPointNum;
    RwV3d m_vAxisX;
    RwV3d m_vAxisY;
    RwV3d m_vAxisZ;
    TRANSITION m_InitTransition;
    PEFINFO::PARTICLETYPE m_type;
    PEFINFO::BLENDTYPE m_blend;
    PEFINFO::PARTICLEKIND m_kind;
    uint32 m_uPatternFlag;
    uint32 m_uLinearFlag;
    float m_fAppearStart;
    float m_fAppearEnd;
    float m_fAppearTiming;
    float m_fEndTime;
    RwV3d m_vBasisPositionForAll;
    RwV3d m_vOriginPosition;
    RwV3d m_vOriginVecFirst;
    RwV3d m_vOriginAcceleration;
    uint32 m_uRandCheckFlag;
    RwV3d m_vRandPosition;
    RwV2d m_vRandSize;
    RwV3d m_vRandFirstVec;
    float m_fRandSpeedFirst;
    RwV3d m_vRandAcceleration;
    float m_fRandAccel;
    float m_fRandLiveCount;
    float m_fRandOccurTiming;
    float m_fRandScaleMin;
    float m_fRandScaleMax;
    RwV3d m_vRandScale3D;
    float m_fRandAngle;
    float m_fCircleRadius;
    float m_fCircleSpeed;
    float m_fCircleBaseRotation;
    float m_fAccelSizeDecayWidth;
    float m_fAccelSizeDecayHeight;
    float m_fAccelRotationBillboard;
    RwV3d m_vAccelRotation;
    float m_fAccelSizeDecayWidthBuffer;
    float m_fAccelSizeDecayHeightBuffer;
    float m_fAccelRotationBillboardBuffer;
    RwV3d m_vAccelRotationBuffer;
    float m_fTimer;
    float m_fGravity;
    PEFINFO::CLIPPINGTYPE m_clippingtype;
    float m_fClippingParameter;
};